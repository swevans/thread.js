{"name":"Thread.js","tagline":"A lightweight multithreading library for JavaScript.","body":"Thread.js is lightweight multithreading library for the JavaScript <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API\">Web Worker API</a>. Web Workers are powerful and fast, but the code required to use them is <a target=\"_blank\" href=\"http://www.html5rocks.com/en/tutorials/workers/basics/\">unintuitive, cumbersome, and error prone</a>. This library was created to make writing parallel applications easier and faster.\r\n</p>\r\n<p>\r\nThread.js provides an intuitive, high-level interface for Web Worker creation, programming, communication, and termination. It works in any browser that <a href=\"http://caniuse.com/#feat=webworkers\">supports Web Workers</a> (IE10+).\r\n</p>\r\nKey Features:\r\n* FEATURES NEEDED\r\n* FEATURES NEEDED\r\n* FEATURES NEEDED\r\n* FEATURES NEEDED\r\n<br/>\r\n<br/>\r\n\r\n\r\n<a name=\"download\"></a>\r\n## Download\r\nDownload the latest versions of Thread.js here:\r\n###### Latest JavaScript Release\r\n<pre>\r\nMinified: <a download href=\"http://spencer-evans.com/share/github/threadjs/latest/thread.min.zip\">thread.min.js</a>\r\nUnminified: <a downlod href=\"http://spencer-evans.com/share/github/threadjs/latest/thread.zip\">thread.js</a>\r\n</pre>\r\n<br/>\r\n\r\n\r\n<a name=\"installation\"></a>\r\n## Installation \r\nInclude thread.js in your projects like so:\r\n###### Tag Loading\r\n```html\r\n<!-- Minified version, recommended for release -->\r\n<script src=\"pathto/thread.min.js\"></script>\r\n\r\n<!-- Full version, recommended for debugging -->\r\n<script src=\"pathto/thread.js\"></script>\r\n```\r\n</br>\r\n\r\n\r\n<a name=\"gettingStarted\"></a>\r\n## Getting Started\r\nThread.js is simple enough that we can just jump into code. The below code creates a thread and runs some code on it. We've created a fiddle to show how easy it is. <a target=\"_blank\" href=\"http://jsfiddle.net/swevans/57exndpp/6/\">Try it yourself</a>.\r\n```js\r\n// Check for threadjs support in the current browser\r\nif (threadjs.isSupported)\r\n{\r\n\t// Start a thread and have it evaluate the supplied function\r\n\tvar myThread = new Thread(function()\r\n\t{\r\n\t\t// do something in the thread\r\n\t\tconsole.log(\"hello world!\");\r\n\t});\r\n}\r\n```\r\nNow move on to the [Usage Guide](#usage) to learn more about working with Threads.\r\n</br>\r\n<br/>\r\n\r\n<a name=\"toc\"></a>\r\n## Table of Contents\r\nThere is a lot to thread.js, choose a section below\r\n* [Usage Guide](#usage)\r\n\t* Concepts - A brief description explaining thread scope, parent child relationship, messaging, and an image\r\n\t* [Creating a Thread](#creatingAThread)\r\n\t* [Adding Thread Logic](#addThreadLogic)\r\n\t* [Running Thread Logic](#run)\r\n\t* [Communicating with Threads](#comm)\r\n\t* [Terminating Threads](#termination)\r\n* [Examples](#examples)\r\n* [Browser Support](#browsers)\r\n* [FAQ](#faq)\r\n* Full Documentation - link to javadocs or page with docs...\r\n* [Advanced Topics](#advanced)\r\n\t* [Thread Events](#threadEvents)\r\n\t* [Sub Threads (Sub Workers)](#subThreads)\r\n\t* [Thread Scope & Loading within a Thread](#threadScope)\r\n\t* [Passing Data Between Threads](#passingData)\r\n\t* [Asynchronously Loading Thread.js](#asyncLib)\r\n\t* [Cross Domain Security (CORS)](#CORS)\r\n\t* [Thread Queuing, Max Workers, and Thread Lock](#queuing)\r\n\t* [Memory & Traffic Optimization](#optimization)\r\n\t* [Debugging & Error Handling](#debugging)\r\n* [Future Changes](#future)\r\n* [Under the Hood](#underTheHood)\r\n* [Compiling TypeScript](#compilingTS)\r\n<br/>\r\n<br/>\r\n\r\n<a name=\"usage\"></a>\r\n## Usage Guide\r\nUsing a thread.js is really simple. There are essentially five things you can do.\r\n<ol>\r\n<li>Create a thread</li>\r\n<li>Add logic to your thread</li>\r\n<li>Run logic on your thread</li>\r\n<li>Communiate with your thread</li>\r\n<li>Terminate the thread when its done</li>\r\n</ol>\r\n<a name=\"creatingAThread\"></a>\r\n#### Creating a Thread\r\nSimply instantiate a new thread object to create a thread. The thread will typically start running immediately. If all workers are currently in use, it will [queue](#queuing) until more worker resources become available. Either way, your thread instance is ready to work with.\r\n###### new Thread();\r\n```js\r\n// Create a thread using the new keyword\r\nvar myThread = new Thread();\r\n```\r\n<br/>\r\n\r\n\r\n<a name=\"addThreadLogic\"></a>\r\n#### Adding Thread Logic\r\nYou can add logic to a thread by importing scripts, adding script, or defining script. Importing an external js file is the best way to add lots of code to the thread. Scripts are loaded synchronously within the thread; no other code within the scope of a thread will execute until the script is loaded and evaluated.\r\n###### Importing Scripts\r\n```js\r\n// Loads two scripts into the thread's scope\r\n// A loads, A evaluates, B loads, B evaluates\r\nmyThread.importScripts(\"scriptA.js\");\r\nmyThread.importScripts(\"scriptB.js\");\r\n\r\n// You can also load multiple scripts at once\r\n// A and B load, A evaluates, B evaluates\r\nmyThread.importScripts(\"scriptA.js\", \"scriptB.js\");\r\n\r\n// Another option is to specify scripts to load in the constructor\r\n// A and B load, A evaluates, B evaluates\r\nvar myThread = new Thread(\"scriptA.js\", \"scriptB.js\");\r\n```\r\n\r\n###### Adding Script\r\n```js\r\n// You can add code to the thread via one big body function\r\n// This is another fast way to add a large amount of code\r\nfunction threadCode()\r\n{\r\n\t// The code within this function will be added to the threads' global scope\r\n}\r\nmyThread.addScripts(threadCode);\r\n\r\n// Another option is to add a script tag\r\n// If we had the following script tag in our html\r\n// it won't evaluate on the main thread, but can be loaded into the child thread\r\n// <script id=\"threadCode\" type=\"text/js-worker\">console.log('hello from thread!');</script>\r\nmyThread.addScripts(document.getElementById(\"threadCode\"));\r\n\r\n// One last option is to supply the constructor with function references or tags\r\n// This is pretty powerful as you can mix and match how you add code\r\n// Adds threadCode function, Adds threadCode tag, finally loads and evaluates script A\r\nvar myThread = new Thread(threadCode, document.getElementById(\"threadCode\"), \"scriptA.js\");\r\n```\r\n\r\n###### Defining Script\r\n```js\r\n/** An example function to run on a thread. */\r\nfunction myEchoFunc(a, b)\r\n{\r\n\tconsole.log(\"Echo on thread: \" + a + \" \" + b);\r\n}\r\n\r\n// Copies a named function to the thread's global scope\r\nmyThread.define(myEchoFunc);\r\n\r\n// Defines a variable in thread's global scope\r\nmyThread.define(\"keyToUniverse\", 42); // runs var keyToUniverse = 42;\r\n```\r\n<br/>\r\n\r\n\r\n<a name=\"run\"></a>\r\n#### Running Thread Logic\r\nYou can invoke logic on a thread using a few thread methods.\r\n###### Calling Functions\r\n```js\r\n/** An example function to run on a thread. */\r\nfunction myEchoFunc(a, b)\r\n{\r\n\tconsole.log(\"Echo on thread: \" + a + \" \" + b);\r\n}\r\nmyThread.define(myEchoFunc);\r\n\r\n// You can call any named function that is loaded or defined in the thread\r\n// You may optionally provide a list of paramaters\r\n// Parameters may be any json cloneable object\r\nmyThread.call(\"myEchoFunc\", \"My name is: \", \"Bob\"); // supply 2 params\r\nmyThread.call(\"someOtherFunc\");                     // no params\r\nmyThread.call(\"myNamespace.anotherFunc\");\r\n```\r\n\r\n###### Anonymous Functions\r\n```js\r\n// You can execute a function once using exec()\r\n// Exec will temporarily define the function, then call it\r\n// This can be an anonymous function or a named function that\r\n// exists in the main code\r\nmyThread.exec(function(param1) { /* do something */ }, \"paramValue\");\r\n```\r\n\r\n###### Constructing Objects\r\n```js\r\n// You can also construct any named function in the thread\r\n// You can optionally provide a list of paramaters\r\n// This example constructs MyClassName with a string and object param\r\nmyThread.construct(\"MyClassName\", \"param1\", { keyToUniverse: 42 });\r\nmyThread.construct(\"myNamespace.MyNamespacedClass\");  // You can use namespaces\r\n```\r\n\r\n###### Eval\r\n```js\r\n// You can also evaluate any javascript in the threads scope\r\n// There are generally better ways to do things, but this \r\n// function can be handy from time to time\r\nmyThread.eval(\"console.log('hi from the thread!');\");\r\n```\r\n<br/>\r\n\r\n\r\n<a name=\"comm\"></a>\r\n#### Communicating with Threads\r\nYou can communicate with threads using events or messages. Communication is a two way street:\r\n\r\n* Communication from Parent to Child\r\n\t* Parent code calls functions on the myThread instance\r\n\t* Child code catches incoming messages by listening to the Thread.parent static class member\r\n* Communication from Child to Parent\r\n\t* Child code calls functions on the Thread.parent static class member\r\n\t* Parent code catches incoming messages by listening to the myThread instance\r\n\r\nEvents are superiour to messages because they can be dispatched to specific event listeners, whereas messages don't have a type.<br/>\r\n<br/>\r\nThe examples below send a ping event/message from the main code (parent) to the child thread. The child then responds to the ping by sending a pong event/message back to the parent. \r\n\r\n###### Events Example\r\n```js\r\n/** Defines the code that will run in the thread. */\r\nfunction threadCode()\r\n{\r\n\t/** Handles ping events sent to the thead. */\r\n\tfunction pingHandler(evt) \r\n\t{\r\n\t\t// Send back a pong\r\n\t\tThread.parent.postEvent(\"pong\", \"Hi from thread \" + Thread.threadID);\r\n\t}\r\n\t\r\n\t// Watch for ping events from the parent\r\n\tThread.parent.addEventListener(\"ping\", pingHandler);\r\n}\r\n\r\n/** Will run in Main window context to handle pong events from the child thread. */\r\nfunction pongHandler(evt) \r\n{\r\n\tconsole.log(\"Received pong from thread!\");\r\n\tconsole.log(\" Got message: \" + evt.data);\r\n}\r\n\r\n// Create a new thread and watch for pong events from it\r\nvar myThread = new Thread(threadCode);\r\nmyThread.addEventListener(\"pong\", pongHandler);\r\n\r\n// Send a ping event to the thread\r\nmyThread.postEvent(\"ping\");\r\n```\r\n\r\n###### Messages Example\r\n```js\r\n/** Defines the code that will run in the thread. */\r\nfunction threadCode()\r\n{\r\n\t/** Handles ping events sent to the thead. */\r\n\tfunction msgHandler(evt) \r\n\t{\r\n\t\t// Send back a pong if the message was a ping\r\n\t\tif (evt.data === \"ping\")\r\n\t\t{\r\n\t\t\tThread.parent.postMessage(\"pong\");\r\n\t\t}\r\n\t}\r\n\t\r\n\t// Watch for ping events from the parent\r\n\tThread.parent.addEventListener(Thread.MESSAGE, msgHandler);\r\n}\r\n\r\n/** Will run in Main window context to handle pong events from the child thread. */\r\nfunction msgHandler(evt) \r\n{\r\n\t// Respond to the message if it was a pong\r\n\tif (evt.data === \"pong\")\r\n\t{\r\n\t\tconsole.log(\"Received pong from thread!\");\r\n\t\tconsole.log(\" Got message: \" + evt.data);\r\n\t}\r\n}\r\n\r\n// Create a new thread and watch for pong events from it\r\nvar myThread = new Thread(threadCode);\r\nmyThread.addEventListener(Thread.MESSAGE, msgHandler);\r\n\r\n// Send a ping event to the thread\r\nmyThread.postMessage(\"ping\");\r\n```\r\n<br/>\r\n\r\n\r\n<a name=\"termination\"></a>\r\n#### Terminating a Thread\r\nThreads use resources that need to be explicitely cleaned up when you're done with the thread. By default, thread.js will only support between 4 and 16 concurrent workers (depending on hardware). Any more than the allowed number, and threads will queue, waiting for existing threads to terminate. Remember to call terminate()- It's super important to clean your room!\r\n\r\nThere are two ways to terminate a thread, from the parent or from the child. Any fully terminated thread is no longer valid.\r\n###### terminate();\r\n```js\r\n// To terminate a thread instance within the parent, you call terminate on the thread instance\r\n// The thread will immediately terminate, any pending messages to the thread will be ignored\r\n// Trying to interact with a terminated thread will throw an error\r\nmyThread.terminate();\t// in parent code\r\n\r\n// To have a child thread terminate itself, call the static terminate function from within the thread\r\n// This will schedule the thread for termination, pending messages may still arrive until termination\r\nThread.terminate();\t// in thread code\r\n```\r\n<br/>\r\n\r\n\r\n<a name=\"examples\"></a>\r\n## Examples\r\nWe've compiled a couple Thread.js examples that show off using events and performing intensive operations. More examples are sure to come in the future.\r\n* **<a target=\"_blank\" href=\"http://jsfiddle.net/swevans/mLbzmtm5/13/\">JSFiddle Events Example</a>** - Dispatches ping and pong events as shown above\r\n* **<a target=\"_blank\" href=\"http://jsfiddle.net/swevans/5m6rqsro/9/\">JSFiddle Prime Numbers Example</a>** - Performs intensive operations without disrupting animation\r\n<br/>\r\n<br/>\r\n\r\n\r\n<a name=\"browsers\"></a>\r\n## Browser Support\r\nThread.js works anywhere that WebWorkers are supported.\r\n* **<a target=\"_blank\" href=\"http://caniuse.com/#feat=webworkers\">Can I Use? Table for Web Workers</a>**\r\n\r\n###### Quirks:\r\n<ol>\r\n<li>IE10: <a target=\"_blank\" href=\"http://www.html5rocks.com/en/tutorials/workers/basics/#toc-inlineworkers\">Inline workers</a> are not supported. Thread.js will fall back to url based web workers, loading the library itself as the root code.</li>\r\n<li>IE10: Because IE10 uses url based workers, it is subject to <a target=\"_blank\" href=\"http://www.html5rocks.com/en/tutorials/cors/\">CORS limitations</a>. There may be a fix coming for this in the future, but we'll have to see how much of an issue it is!</li>\r\n</ol>\r\n<br/>\r\n\r\n\r\n<a name=\"faq\"></a>\r\n## FAQ\r\n**Q: I am calling a function on my thread then terminating the thread and the function never evaluates, why?!**<br/>\r\n**A:** Calling myThread.terminate() terminates the thread immediately. The prior function you're calling via myThread.call() is schedule to be called, but the thread terminates before it does. You should use events or messages to let the parent know the thread is done, OR have the thread terminate itself. \r\n```js\r\nfunction threadCode {\r\n\tfunction myFunc()\r\n\t{\r\n\t\t// do some things\r\n\t\t\r\n\t\t// now self terminate\r\n\t\tThread.terminate();\r\n\t}\r\n}\r\nvar myThread = new Thread(threadCode);\r\nmyThread.call(\"myFunc\");\r\n```\r\n<br/>\r\n\r\n**Q: I am using many threads and nothing seems to be getting done or a thread never starts, why?!**<br/>\r\n**A:** You're likely creating too many threads that are waiting for one another to finish. Lets say you have four threads; A, B, C, and D. You then create a 5th thread E. The thread code in A, B, C, and D all rely on E to finish, however E will never be able to start because A, B, C, and D are using all available workers. This is thread lock. You should first try to remove this dependancy. If you can't, increase max workers with threadjs.maxWorkers = 16; (be careful with this and don't go over 16!). See the [Max Workers and Thread Queuing](#queuing) section below.\r\n<br/>\r\n<br/>\r\n\r\n<a name=\"advanced\"></a>\r\n## Advanced Topics\r\nThread.js is simple enough to pick up quickly, but there are a few advanced topics worth posting.\r\n##### Checking for Suppport\r\nYou can check for browser support using:\r\n```js\r\n// Will be true if the Web Worker API is supported\r\nthreadjs.isSupported;\r\n```\r\n<br/>\r\n\r\n<a name=\"threadEvents\"></a>\r\n##### Thread Events\r\nThe Thread class has a few built in events. It is not necessary to use them. They're provided more for debugging than anything else.\r\n```js\r\n/** Code within the parent */\r\n// The start event is dispatched when a thread starts \r\n// This might be dispatched within the Thread() constructor and thus you can't catch it\r\n// You'll only catch this event if the thread was queued, see Thread Queuing topic\r\n// The event type is a ThreadEvent\r\nmyThread.addEventListener(Thread.START, startHandler);\r\n\r\n// Catches messages sent from child to parent\r\n// Only applies if you're using Thread.parent.postMessage\r\n// It is recommended that you use postEvent instead\r\n// The event type is a MessageEvent\r\n// Data passed with the message is in the data member of the event\r\nmyThread.addEventListener(Thread.MESSAGE, msgFromChildHandler);\r\n\r\n// Dispatched whenever a thread actually terminates\r\n// You can use this to tell if your thread self terminated via a static Thread.terminate()\r\n// The event type is a ThreadEvent\r\nmyThread.addEventListener(Thread.TERMINATE, terminateHandler);\r\n\r\n// Dispatched whenever an error is thrown within the thread code\r\n// The event type is some form of ErrorEvent\r\nmyThread.addEventListener(Thread.ERROR, errorHandler);\r\n\r\n/** Code within the thread */\r\n// Catches messages sent from parent to child\r\n// Only applies if you're using myThread.postMessage\r\n// It is recommended that you use postEvent instead\r\n// The event type is a MessageEvent\r\n// Data passed with the message is in the data member of the event\r\nThread.parent.addEventListener(Thread.MESSAGE, msgFromParentHandler);\r\n```\r\n<br/>\r\n\r\n<a name=\"subThreads\"></a>\r\n##### Sub Threads (Sub Workers)\r\nThread.js supports child threads, aka Sub Workers. You may spawn a thread within a thread. The maxWorkers limit and thread queuing are still enforced. See [Max Workers and Thread Queuing](#queuing) below. Sub Threads are very-slightly slower to start.<br/>\r\n<p>\r\nSub threads are dependant on their parent; when the parent terminates, the child will terminate. An example; Your main code in index.html creates myThread, myThread then creates mySubThread, index.html calls myThread.terminate(), both mySubThread and myThread will terminate.\r\n</p>\r\n```js\r\n// Define code for the thread\r\nfunction myThreadCode() {\r\n\r\n\t// Define code for the sub thread\r\n\tfunction mySubThreadCode() {}\r\n\t\r\n\t// Create the sub thread\r\n\tvar mySubThread = new Thread(mySubThreadCode);\r\n}\r\n\r\n// Create the thread, which in turn creates a sub thread\r\nvar myThread = new Thread(myThreadCode);\r\n\r\n// Terminate myThread, which will also terminate mySubThread\r\nmyThread.terminate();\r\n```\r\n<br/>\r\n\r\n<a name=\"threadScope\"></a>\r\n##### Thread Scope & Loading within a Thread\r\n<p>\r\nThreads operate in their own execution scope. Thus code must be loaded into the thread even if it already exists in the parent scope. Additionally, thread scope does not have access to the DOM or window.\r\n</p>\r\n<p>\r\nOne benefit to loading within a thread is that loading can be done synchronously without disrupting user experience. On the flip side, a drawback is that urls provided to loaders must be absolute. Thread.js makes this simple by providing the Thread.workingDirectory static member. An example below shows how to use it.\r\n</p>\r\n```js\r\nfunction threadCode()\r\n{\r\n\t// load something synchronously within the thread\r\n\t// using Thread.workingDirectory and a url that is relative to the page\r\n\tvar xhttp = new XMLHttpRequest();\r\n  \txhttp.open(\"GET\", Thread.workingDirectory + \"myFile.txt\", false);\r\n  \txhttp.send();\r\n}\r\n\r\nvar myThread = new Thread(threadCode);\r\n```\r\n<br/>\r\n\r\n<a name=\"passingData\"></a>\r\n##### Passing Data Between Threads\r\n<p>\r\nObjects are passed between threads via cloning. The actual instances of the objects are not shared. This is a limitation of the Web Worker API. An additional limitation is that you cannot pass objects that contain native code (ie HTMLElements).\r\n</p>\r\n<p>\r\nOne exception is that you may post native events (like a mouse event) between threads using postEvent(someNativeEvent). This is accomplished by creating a partial copy of the native event as a ThreadEvent.\r\n</p>\r\n<p>\r\nAs of now, Thread.js only supports copying data between threads. Transferrable objects are not yet supported.\r\n</p>\r\n<br/>\r\n\r\n<a name=\"asyncLib\"></a>\r\n##### Asynchronously Loading Thread.js\r\nIt is highly recommended that you load thread.js using a synchronous script tag within your document. If for some reason you must load thread.js using an asynchronous method, you are required to set the threadjs.url property before using Threads. It should point to the location of the thread.js library file.\r\n```js\r\n// ... some code to load and evaluate thread.js\r\n\r\n// Set the threadjs url relative to the document\r\nthreadjs.url = \"pathto/thread.js\";\r\n```\r\n<br/>\r\n\r\n<a name=\"CORS\"></a>\r\n##### Cross Domain Security (CORS)\r\nIt is highly recommended that you host thread.js and your thread code scripts in the same domain as your page. If for some reason you can't, you will lose IE10 support. You may also run into security issues loading your thread code if it is in a different domain than the threadjs library.\r\n<br/>\r\n<br/>\r\n\r\n<a name=\"queuing\"></a>\r\n##### Thread Queuing, Max Workers, and Thread Lock\r\nThread.js only allows a maximum number of workers. This is typically 4 by default, but may go up to 16 depending on device hardware. This limitation is to prevent you from accidentally crashing the browser by creating too many workers. However, you can create as many Thread instances as you want and act on them immediately. This is thanks to thread.js's Thread Queuing functionality.\r\n###### Thread Queuing\r\n<p>\r\nIf you create more threads than the allowed number of workers, the threads created most recently will queue until a worker become available when an existing thread terminates. Queued threads will dequeue and start in the order they are created.\r\n</p>\r\n<p>\r\nA Thread.START (\"start\") event is dispatched by the thread instance when it dequeues. Even if a thread queues, you may call any functions on it. Any functions you call on a queued thread will execute, in order, after the thread starts. If you call terminate on a queued thread, it will never start and no longer be valid.\r\n</p>\r\n<a name=\"maxWorkers\"></a>\r\n###### Max Workers\r\n<p>\r\nThe maximum number of workers is safely determined by Thread.js when the library is loaded. It is safest to assume that this value is 4. You can manually increase this number (not recommended) by setting threadjs.maxWorkers. You should probably not set this above 12, and definitely not set this value above 16 for anything you plan to release. Setting this value too high will cause the browser to crash.\r\n</p>\r\n###### Thread Lock\r\n<p>\r\nThread lock happens when you have active threads which depend on queued threads. This is something you should avidly try to avoid by removing thread dependancies and avoiding sub threads.\r\n</p>\r\n<br/>\r\nAn Example:<br/>\r\nLet's say you have four threads; A, B, C, and D. You then create a 5th thread E. The thread code in A, B, C, and D all rely on E to finish, however E will never be able to start because A, B, C, and D are using all available workers. This is thread lock. You should first try to remove this dependancy. If you can't, then your only option is to increase max workers with threadjs.maxWorkers (be careful with this and don't go over 16!). See the [Max Workers](#maxWorkers) section above.\r\n<br/>\r\n\r\n\r\n<a name=\"optimization\"></a>\r\n##### Memory & Traffic Optimization\r\nCode supplied to the thread might be lengthy and heavy to keep in memory. If you define the code inline in your main javascript, the code will be stored in memory on both the parent and child thread. If you use the script tag code definition defined above, the code won't be defined in memory on the main thread. The absolute best way to conserve memory and traffic is to define your thread code in an external js file.\r\n###### Inline Thread Code\r\n```js\r\n// threadCode src will obviously download with the page\r\n// threadCode will exist in memory in the page root and the thread.\r\nfunction threadCode() {\r\n\t// some code\r\n}\r\nvar myThread = new Thread(threadCode);\r\n```\r\n###### Tag Defined Thread Code\r\n```html\r\n<html>\r\n\t<head>\r\n\t\t <script id=\"threadCode\" type=\"text/js-worker\">\r\n\t\t\t// threadCode src will obviously download with the page\r\n\t\t\t// threadCode will exist in memory only in the thread\r\n\t\t\tfunction threadCode() {\r\n\t\t\t\t// some code\r\n\t\t\t}\r\n\t\t</script>\r\n\t\t<script>\r\n\t\t\tvar myThread = new Thread(document.getElementById(\"threadCode\"));\r\n\t\t</script>\r\n\t</head>\r\n</html>\r\n```\r\n###### Externally Loaded Thread Code\r\n```js\r\n// threadCode src will only download when the thread starts\r\n// threadCode will only exist in memory within the thread only\r\nvar myThread = new Thread(\"myThreadCode.js\");\r\n```\r\n<br/>\r\n\r\n<a name=\"debugging\"></a>\r\n##### Debugging & Error Handling\r\nDebugging multithreaded code can be challenging. Luckily Threadjs and Web Workers provide some safety and help. As always.. your browser console is there to help (use F12)! FWIW- we have found Firefox to be the best browser for debugging multithreaded code.\r\n###### Unminified Thread.js\r\nIt is best to use the unminified thread.js file while developing or debugging your application.\r\n```html\r\n<!-- Full version, recommended for debugging -->\r\n<script src=\"pathto/thread.js\"></script>\r\n```\r\n###### Disallowing Inline Workers\r\nInline workers create fictional urls to run code. Threadjs uses inline workers by default. These can be tricky to debug because file name and line information may be lost. Thankfully, you can disable inline workers.\r\n```js\r\nthreadjs.allowInlineWorkers = false;\t// turn off inline workers\r\n```\r\n###### Catching Errors Generated in the Thread\r\nThread instances dispatch an error event anytime their thread code throws an error. You can catch it like so:\r\n```js\r\n// Dispatched whenever an error is thrown within the thread code\r\n// The event type is some form of ErrorEvent\r\nmyThread.addEventListener(Thread.ERROR, function(errorEvent) {/* do something */} );\r\n```\r\n<br/>\r\n\r\n\r\n<a name=\"future\"></a>\r\n## Future Changes\r\nThere are many different ways to expand upon Thread.js. Feel free to weigh in on future direction by forking the repo, adding a comment, or emailing me at <a target=\"_blank\" href=\"mailto:evans.spencer@gmail.com\">evans.spencer@gmail.com</a>. Here are a few things being considered:\r\n * Wrapper for objects constructed on the thread via myThread.construct(). Will allow you to call functions on the constructed object.\r\n * Wrapper for function calls on the thread via myThread.call(). Will allow you to listen for function completion and get the return result.\r\n * Change importScripts to use XHR such that CORS is supported.\r\n * Add support for transferrable objects.\r\n * Add a object sync feature that mirrors an object between two threads.\r\n * Add support for synchronous threads when workers are not supported.\r\n<br/>\r\n<br/>\r\n\r\n\r\n<a name=\"underTheHood\"></a>\r\n## Under the Hood\r\nFor those who already understand Web Workers, here a few details about how Thread.js works.\r\n###### Worker Types:\r\n* Thread.js only uses dedicated workers.\r\n* Thread.js uses <a target=\"_blank\" href=\"http://www.html5rocks.com/en/tutorials/workers/basics/#toc-inlineworkers\">inline workers</a> whenever possible. IE10 is the only known browser that does not support inline workers.\r\n* Thread.js currently uses the web worker API <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/importScripts\">importScripts</a> function to load scripts in a thread. This limits non-inline workers and script importing to the same origin. \r\n \r\n###### Max Workers:\r\n* Thread.js uses the navigator.hardwareConcurrency to determine the maximum number of workers allowed. Thread.js enforces a default minimum number of 4 workers and a max of 16. Any number of thread instances can be created, but they will queue until more workers become available. You can override this setting with the threadjs.maxWorkers property.\r\n* Thread.js allows sub-workers but enforces a maximum number of workers by keeping track of all descendant threads within the Main UI process.\r\n\r\n###### Base Thread Code:\r\n* Whenever a new worker is created, it is immediately passed all of the threadjs library, making the library available on that thread. \r\n\r\n###### Working Directory, Library URL, and CORS:\r\n* Threadjs maintains a string url to the working directory of the web page. This url is passed to all threads to allow script loading when workers are not running in the page location. You can find this value in Thread.workingDirectory.\r\n* Threadjs needs to know its own library script url. This is determined when the library is loaded by looking at the last script tag loaded in the DOM. If you load thread.js via XHR / jQuery / some other means, you will need to set the threadjs.url property immediately after importing the library.\r\n\r\n###### Event System:\r\n* Threadjs has its own tiny, built-in EventTarget like interface called EventDispatcher. It allows Thread.js to dispatch events. \r\n* Threadjs allows you to partially pass native events between threads by creating a partial copy of the native event as a threadjs ThreadEvent. Thus you can pass myThread.postEvent(mouseEvent) etc.\r\n<br/>\r\n<br/>\r\n\r\n<a name=\"compilingTS\"></a>\r\n## Compiling TypeScript\r\nCompiling the typescript is not required to use the library. Should you decide to do so, run the compiler within the src directory. It should pickup the tsconfig.json configuration file and output to www/js/thread.js.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}